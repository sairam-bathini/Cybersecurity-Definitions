
Insecure Direct Object References (IDOR) occur when an application provides direct access to objects based on user-supplied input, without proper authorization checks. This can allow attackers to access or manipulate data they are not authorized to access.

Example: IDOR in User Profile API
Consider a web application with a User Profile API that allows users to retrieve their profile information. The API endpoint might look something like this:

User Profile API Endpoint:
sql
Copy code
GET /api/user/profile?userId=123
When a user makes a request to this endpoint with their userId, the application retrieves and returns their profile information.

Example Scenario:
Authenticated User:

Alice logs into the application and her user ID is 123.
She accesses her profile by making a request to /api/user/profile?userId=123.
The application retrieves and returns Alice's profile information.
IDOR Vulnerability:

The application does not properly check if the userId in the request belongs to the authenticated user.
Bob, another user whose user ID is 456, can manipulate the request to access Alice's profile:
sql
Copy code
GET /api/user/profile?userId=123
If the application does not verify that userId=123 belongs to the authenticated user (Bob), it will return Alice's profile information to Bob.
Code Example:
Vulnerable Code (C#):
csharp
Copy code
[HttpGet]
[Route("api/user/profile")]
public IActionResult GetUserProfile(int userId)
{
    var user = db.Users.SingleOrDefault(u => u.UserId == userId);
    if (user == null)
    {
        return NotFound();
    }
    return Ok(user);
}
In the above code, the application directly retrieves the user information based on the userId provided in the request without checking if the authenticated user is authorized to access that userId.

Fixing the IDOR Vulnerability:
To fix the IDOR vulnerability, the application should ensure that the authenticated user is only allowed to access their own profile information.

Secure Code (C#):
csharp
Copy code
[HttpGet]
[Route("api/user/profile")]
public IActionResult GetUserProfile()
{
    // Get the authenticated user's ID from the session or token
    var authenticatedUserId = GetAuthenticatedUserId();

    var user = db.Users.SingleOrDefault(u => u.UserId == authenticatedUserId);
    if (user == null)
    {
        return NotFound();
    }
    return Ok(user);
}

private int GetAuthenticatedUserId()
{
    // This method should retrieve the authenticated user's ID from the session or token
    // For example, using JWT:
    // var userId = int.Parse(User.Claims.First(c => c.Type == "userId").Value);
    // return userId;

    // Dummy implementation for demonstration purposes
    return 123; // Replace with actual logic to retrieve the authenticated user's ID
}
In the secure code example, the GetUserProfile method no longer takes userId as a parameter. Instead, it retrieves the authenticated user's ID from the session or token and uses it to fetch the user's profile. This ensures that a user can only access their profile information.

Why This Matters:
Prevents Unauthorized Access: Ensuring proper authorization checks prevents users from accessing or modifying data they are not authorized to access.
Protects User Privacy: Properly securing endpoints that handle sensitive information like user profiles helps protect user privacy.
Enhances Application Security: Fixing IDOR vulnerabilities strengthens the overall security posture of the application, making it less susceptible to malicious attacks.
By implementing proper authorization checks and ensuring that users can only access their data, applications can effectively mitigate IDOR vulnerabilities.